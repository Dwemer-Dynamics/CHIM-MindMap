<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHIM Mind Map 3D</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            color: #fff;
            overflow: hidden; /* Prevent scrollbars from body */
            /* MODIFIED: CSS background properties for cover effect */
            background-image: url('images/background.jpg');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            background-color: #111; /* Fallback color if image fails */
        }
        canvas { display: block; }
        #tooltip { display: none !important; } /* Hide old tooltip permanently */
        #info-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px; /* Adjust width as needed */
            height: 100vh; /* Full viewport height */
            background-color: rgba(30, 30, 30, 0.95); /* MODIFIED: Reverted background color */
            color: #eee;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Add scroll if content overflows */
            border-left: 1px solid #444;
            display: block; /* MODIFIED: Panel is now always visible */
            font-size: 14px;
        }
        #info-panel h3 {
            margin-top: 0;
            color: rgb(212, 94, 0); /* MODIFIED: New text color for h3 */
        }
        #info-panel p {
            margin-bottom: 10px;
            white-space: pre-wrap; /* Preserve line breaks in summary/companions */
        }
        #info-panel .data-section {
            margin-bottom: 15px;
        }
        #info-panel .label {
            font-weight: bold;
            color: #aaa;
        }
        /* Styles for the line toggle switch */
        .toggle-switch-container {
            position: fixed;
            top: 20px;
            left: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000; /* Ensure it's above the canvas */
            display: flex;
            align-items: center;
        }
        .toggle-switch-container label {
            margin-right: 10px;
            font-size: 14px;
            color: #eee;
        }
        /* Basic checkbox styled to look like a simple toggle */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px; /* Width of the toggle */
            height: 20px; /* Height of the toggle */
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555; /* Track color when off */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 20px; /* Rounded track */
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px; /* Knob height */
            width: 16px;  /* Knob width */
            left: 2px;   /* Knob position from left (off) */
            bottom: 2px;  /* Knob position from bottom */
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%; /* Rounded knob */
        }
        input:checked + .slider {
            background-color: rgb(212, 94, 0); /* MODIFIED: Track color when on */
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(20px); /* Knob position when on */
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }
        /* Styles for the companion filter */
        .filter-container {
            position: fixed;
            top: 70px; /* Position below the line toggle */
            left: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        .filter-container label {
            margin-right: 10px;
            font-size: 14px;
            color: #eee;
        }
        .filter-container select {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #555;
            background-color: #444;
            color: #eee;
            min-width: 150px; /* Give it some initial width */
        }
    </style>
</head>
<body>
    <div class="toggle-switch-container">
        <label for="lineToggle">Show Timeline Lines:</label>
        <label class="toggle-switch">
            <input type="checkbox" id="lineToggle" checked>
            <span class="slider"></span>
        </label>
    </div>

    <div class="filter-container">
        <label for="companionFilter">Filter by Person:</label>
        <select id="companionFilter">
            <option value="all">Show All</option>
            <!-- Companion options will be populated here by JavaScript -->
        </select>
    </div>

    <!-- Old tooltip div is effectively removed by CSS -->
    <!-- <div id="tooltip"></div> --> 
    <div id="info-panel">
        <h3>Point Information</h3>
        <div class="data-section">
            <span class="label">Summary:</span>
            <p id="info-summary">No point selected.</p>
        </div>
        <div class="data-section">
            <span class="label">People:</span>
            <p id="info-companions"></p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, controls, labelRenderer;
        const pointsData = []; // To store data associated with each mesh
        let pointMeshes = []; // To store the THREE.Mesh objects for raycasting
        let arrowHelpers = []; // To store arrow helpers for potential removal/update
        let activePoint = null; // For hover effect

        let raycaster, mouse;
        let hoveredPoint = null;
        const tooltip = document.getElementById('tooltip');

        async function fetchData() {
            try {
                const response = await fetch('api.php'); // This path is still correct
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `HTTP error! status: ${response.status}`);
                }
                const data = await response.json();
                console.log("Data fetched:", data);
                return data;
            } catch (error) {
                console.error("Could not fetch data:", error);
                return [];
            }
        }

        function init() {
            scene = new THREE.Scene();

            // REMOVED: Old background image loading via TextureLoader
            // const loader = new THREE.TextureLoader();
            // loader.load('images/background.jpg', function(texture) {
            //     scene.background = texture;
            // }, undefined, function(err) {
            //     console.error('An error happened while loading the background image.', err);
            // });

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30; // Adjusted camera position

            // MODIFIED: Added alpha: true to renderer, and set clear alpha to 0
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Set clear color to transparent
            document.body.appendChild(renderer.domElement);

            // CSS2D Renderer for labels
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none'; // Important for OrbitControls
            document.body.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('click', onClick, false);
            document.addEventListener('mousemove', onMouseMove, false); // Re-enabled for hover cursor

            // Add event listener for the toggle
            document.getElementById('lineToggle').addEventListener('change', function(event) {
                const selectedCompanion = document.getElementById('companionFilter').value;
                filterPointsByCompanion(selectedCompanion);
            });

            fetchData().then(data => {
                if (data && data.length > 0) {
                    visualizeData(data);
                } else {
                    console.log("No data to visualize or error occurred.");
                }
            });
        }

        function visualizeData(data) {
            // --- Cleanup previous objects ---
            pointMeshes.forEach(mesh => scene.remove(mesh));
            arrowHelpers.forEach(arrow => scene.remove(arrow));
            pointMeshes = [];
            arrowHelpers = [];
            pointsData.length = 0;
            // Potentially remove other dynamic objects if re-visualizing

            // --- Prepare for sizing ---
            let minGamets = Infinity;
            let maxGamets = -Infinity;
            data.forEach(item => {
                const gamets = parseInt(item.gamets_truncated, 10);
                if (!isNaN(gamets)) {
                    if (gamets < minGamets) minGamets = gamets;
                    if (gamets > maxGamets) maxGamets = gamets;
                }
            });
            const gametsRange = (maxGamets - minGamets) > 0 ? (maxGamets - minGamets) : 1; // Avoid division by zero

            const scaleFactor = 100; // MOVED scaleFactor DEFINITION HERE

            // --- Define size range for points ---
            const minPointSize = 0.1 * (scaleFactor / 100); // Min size of sphere radius
            const maxPointSize = 0.8 * (scaleFactor / 100); // Max size of sphere radius
            
            const baseSphereRadius = 0.05; // Base radius for spheres before scaling

            // --- Bounding box for camera ---
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            // --- Create points (meshes) and collect positions for arrows ---
            const arrowVertices = []; // Store center positions for arrows

            data.forEach((item, index) => {
                const vec = item.embedding;
                let x, y, z;

                if (vec && vec.length >= 3) {
                    x = vec[0] * scaleFactor;
                    y = vec[1] * scaleFactor;
                    z = vec[2] * scaleFactor;
                } else if (vec && vec.length > 0) {
                    x = (vec[0] || 0) * scaleFactor;
                    y = (vec[1] || 0) * scaleFactor;
                    z = 0;
                } else {
                    return; // Skip if no valid vector
                }

                const currentPosition = new THREE.Vector3(x, y, z);
                arrowVertices.push(currentPosition); 

                // Calculate size based on gamets_truncated (RESTORED)
                let pointSize = minPointSize;
                const gamets = parseInt(item.gamets_truncated, 10);
                if (!isNaN(gamets) && maxGamets > minGamets) {
                    const normalizedGamets = (gamets - minGamets) / gametsRange;
                    pointSize = minPointSize + normalizedGamets * (maxPointSize - minPointSize);
                }
                pointSize = Math.max(0.01 * (scaleFactor/100), pointSize); // Ensure size is not zero or negative, scaled minimum

                const sphereGeometry = new THREE.SphereGeometry(baseSphereRadius, 16, 12); 
                
                let pointColorValue;
                // New color logic based on companions
                let numCompanions = 0;
                if (item.companions && typeof item.companions === 'string' && item.companions.trim() !== '') {
                    numCompanions = item.companions.split(',').length;
                }

                const t = Math.min(1, Math.max(0, numCompanions / 10)); // Normalize between 0 and 1

                // Interpolate between white (255, 255, 255) and red-orange (255, 120, 0)
                const r = 255;
                const g = Math.round(255 - 135 * t); // (255 -> 120)
                const b = Math.round(255 - 255 * t); // (255 -> 0)

                pointColorValue = new THREE.Color(r / 255, g / 255, b / 255);
                
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: pointColorValue });
                const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                
                sphereMesh.position.copy(currentPosition);
                sphereMesh.scale.set(pointSize / baseSphereRadius, pointSize / baseSphereRadius, pointSize / baseSphereRadius); // USE DYNAMIC pointSize

                sphereMesh.userData = { 
                    id: index, 
                    summary: item.summary, 
                    companions: item.companions, 
                    gamets_truncated: item.gamets_truncated,
                    originalColor: pointColorValue.clone(),
                    originalScale: sphereMesh.scale.clone()
                };

                scene.add(sphereMesh);
                pointMeshes.push(sphereMesh);
                pointsData.push(sphereMesh.userData); // Keep pointsData for simpler access patterns if needed, but userData is key

                // Update bounding box
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
                if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
            });

            // --- Create ArrowHelpers for each segment to show direction ---
            if (arrowVertices.length > 1) {
                const arrowColor = 0x00ffff;
                const showLinesInitial = document.getElementById('lineToggle').checked; // Get initial state

                // --- Populate Companion Filter ---
                const companionFilterSelect = document.getElementById('companionFilter');
                const uniqueCompanions = new Set();
                data.forEach(item => {
                    if (item.companions && typeof item.companions === 'string') {
                        const companionsList = item.companions.split(',').map(c => c.trim()).filter(c => c !== '');
                        companionsList.forEach(c => uniqueCompanions.add(c));
                    }
                });
                // Clear existing options except the first 'Show All'
                while (companionFilterSelect.options.length > 1) {
                    companionFilterSelect.remove(1);
                }
                const sortedCompanions = Array.from(uniqueCompanions).sort(); // ADDED: Sort companions alphabetically
                sortedCompanions.forEach(companion => { // MODIFIED: Iterate over sortedCompanions
                    const option = document.createElement('option');
                    option.value = companion;
                    option.textContent = companion;
                    companionFilterSelect.appendChild(option);
                });
                // END ADDED SECTION

                for (let i = 0; i < arrowVertices.length - 1; i++) {
                    const startPoint = arrowVertices[i];
                    const endPoint = arrowVertices[i+1];
                    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
                    const segmentLength = direction.length();
                    if (segmentLength > 0.001) {
                        direction.normalize();
                        let arrowHeadLength = segmentLength * 0.2;
                        let arrowHeadWidth = segmentLength * 0.1;
                        const minAbsHeadLength = 0.1; const maxAbsHeadLength = 1.0 * (scaleFactor/100);
                        const minAbsHeadWidth = 0.05; const maxAbsHeadWidth = 0.5 * (scaleFactor/100);
                        arrowHeadLength = Math.max(minAbsHeadLength, Math.min(arrowHeadLength, maxAbsHeadLength));
                        arrowHeadWidth = Math.max(minAbsHeadWidth, Math.min(arrowHeadWidth, maxAbsHeadWidth));
                        if (arrowHeadLength >= segmentLength * 0.9) {
                            arrowHeadLength = segmentLength * 0.5;
                            arrowHeadWidth = arrowHeadLength * 0.5;
                        }
                        const arrow = new THREE.ArrowHelper(direction, startPoint, segmentLength, arrowColor, arrowHeadLength, arrowHeadWidth);
                        arrow.visible = showLinesInitial; // Set initial visibility
                        scene.add(arrow);
                        arrowHelpers.push(arrow);
                    }
                }
            }
            
            // --- Auto-camera adjustment ---
            if (isFinite(minX) && isFinite(maxX)) {
                const extent = new THREE.Vector3(maxX - minX, maxY - minY, maxZ - minZ);
                const sceneCenter = new THREE.Vector3(minX + extent.x / 2, minY + extent.y / 2, minZ + extent.z / 2);
                controls.target.copy(sceneCenter);
                const maxDimension = Math.max(extent.x, extent.y, extent.z, 1.0); // Ensure maxDimension is at least 1
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDimension / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; 
                cameraZ = Math.max(cameraZ, 10); 
                camera.position.copy(sceneCenter);
                camera.position.z += cameraZ; 
                camera.lookAt(sceneCenter);
                controls.update();
            }
            // Add event listener for the companion filter
            document.getElementById('companionFilter').addEventListener('change', onCompanionFilterChange);

            console.log(`Processed ${pointMeshes.length} points for visualization.`);
            console.log("Camera Position:", camera.position);
            console.log("Controls Target (LookAt):", controls.target);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointMeshes); // Intersect with meshes

            if (activePoint) {
                // Revert previously hovered point
                activePoint.material.color.copy(activePoint.userData.originalColor);
                activePoint.scale.copy(activePoint.userData.originalScale);
                activePoint = null;
            }

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object;
                document.body.style.cursor = 'pointer';
                activePoint = intersectedMesh;
                activePoint.material.color.set(0xff0000); // Highlight red
                activePoint.scale.copy(activePoint.userData.originalScale).multiplyScalar(1.5); // Scale up
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointMeshes); // Intersect with meshes
            
            const infoSummary = document.getElementById('info-summary');
            const infoCompanions = document.getElementById('info-companions');

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object; // The first intersected mesh
                const clickedPointData = clickedMesh.userData;
                
                infoSummary.textContent = clickedPointData.summary || 'Not available';
                infoCompanions.textContent = clickedPointData.companions || 'Not available';
            } else {
                infoSummary.textContent = 'Click a point for details.';
                infoCompanions.textContent = '';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera); // Render CSS2D labels
        }

        // New function to handle companion filter change
        function onCompanionFilterChange(event) {
            const selectedCompanion = event.target.value;
            filterPointsByCompanion(selectedCompanion);
        }

        // New function to filter points and arrows by companion
        function filterPointsByCompanion(selectedCompanion) {
            const showLines = document.getElementById('lineToggle').checked;
            const isShowAll = selectedCompanion === 'all';

            pointMeshes.forEach(mesh => {
                let isVisible = false;
                if (isShowAll) {
                    isVisible = true;
                } else {
                    const companions = mesh.userData.companions || '';
                    if (companions.split(',').map(c => c.trim()).includes(selectedCompanion)) {
                        isVisible = true;
                    }
                }
                mesh.visible = isVisible;
            });

            arrowHelpers.forEach((arrow, index) => {
                // Assuming arrow i connects point i and point i+1
                // This relies on pointMeshes and arrowHelpers being in corresponding order
                // and that arrowHelpers[i] connects pointMeshes[i] to pointMeshes[i+1]
                if (pointMeshes[index] && pointMeshes[index+1]) {
                    const startPointVisible = pointMeshes[index].visible;
                    const endPointVisible = pointMeshes[index+1].visible;
                    arrow.visible = showLines && startPointVisible && endPointVisible;
                } else {
                    arrow.visible = false; // Should not happen if data is consistent
                }
            });
        }

        init();
        animate();
    </script>
</body>
</html> 