<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHIM Mind Map 3D</title>
    <link rel="icon" type="image/x-icon" href="images/favicon.ico">
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            color: #fff;
            overflow: hidden; /* Prevent scrollbars from body */
            /* MODIFIED: CSS background properties for cover effect */
            background-image: url('images/background.jpg');
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            background-color: #111; /* Fallback color if image fails */
        }
        canvas { display: block; }
        #tooltip { display: none !important; } /* Hide old tooltip permanently */
        #info-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 300px; /* Adjust width as needed */
            height: 100vh; /* Full viewport height */
            background-color: rgba(30, 30, 30, 0.95); /* MODIFIED: Reverted background color */
            color: #eee;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto; /* Add scroll if content overflows */
            border-left: 1px solid #444;
            display: block; /* MODIFIED: Panel is now always visible */
            font-size: 14px;
        }
        #info-panel h3 {
            margin-top: 0;
            color: rgb(212, 94, 0); /* MODIFIED: New text color for h3 */
        }
        #info-panel p {
            margin-bottom: 10px;
            white-space: pre-wrap; /* Preserve line breaks in summary/companions */
        }
        #info-panel .data-section {
            margin-bottom: 15px;
        }
        #info-panel .label {
            font-weight: bold;
            color: #aaa;
        }
        /* Styles for the line toggle switch */
        .toggle-switch-container {
            position: fixed;
            top: 20px; /* Remains at the top */
            left: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000; /* Ensure it's above the canvas */
            display: flex;
            align-items: center;
        }
        .toggle-switch-container label {
            margin-right: 10px;
            font-size: 14px;
            color: #eee;
        }
        /* Basic checkbox styled to look like a simple toggle */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 40px; /* Width of the toggle */
            height: 20px; /* Height of the toggle */
        }
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555; /* Track color when off */
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 20px; /* Rounded track */
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px; /* Knob height */
            width: 16px;  /* Knob width */
            left: 2px;   /* Knob position from left (off) */
            bottom: 2px;  /* Knob position from bottom */
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            border-radius: 50%; /* Rounded knob */
        }
        input:checked + .slider {
            background-color: rgb(212, 94, 0); /* MODIFIED: Track color when on */
        }
        input:checked + .slider:before {
            -webkit-transform: translateX(20px); /* Knob position when on */
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }
        /* Styles for the companion filter */
        .filter-container {
            position: fixed;
            top: 120px; /* MODIFIED: Below Memory Size Slider (70px + ~40px height + 10px gap) */
            left: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        .filter-container label {
            margin-right: 10px;
            font-size: 14px;
            color: #eee;
        }
        .filter-container select {
            padding: 5px;
            border-radius: 3px;
            border: 1px solid #555;
            background-color: #444;
            color: #eee;
            min-width: 250px; /* MODIFIED: Increased width */
        }
        /* Styles for the point size slider */
        .slider-container {
            position: fixed;
            top: 70px; /* MODIFIED: Below Line Toggle (20px + ~40px height + 10px gap) */
            left: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            display: flex;
            align-items: center;
        }
        .slider-container label {
            margin-right: 10px;
            font-size: 14px;
            color: #eee;
        }
        .slider-container input[type="range"] {
            width: 120px; /* Adjust width as needed */
            cursor: pointer;
            -webkit-appearance: none; /* Override default appearance */
            appearance: none;
            height: 8px; /* Track height */
            background: #555; /* Track background */
            border-radius: 5px;
            outline: none;
        }

        /* Thumb (handle) styling */
        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; /* Thumb width */
            height: 18px; /* Thumb height */
            background: rgb(212, 94, 0); /* Orange thumb color */
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff; /* White border for contrast */
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: rgb(212, 94, 0);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff;
        }

        /* Optional: Style the track for Firefox - for full orange track, this might be tricky */
        /* For a simpler cross-browser look, the thumb color is usually the main focus */
        .slider-container input[type="range"]::-moz-range-track {
            background: #555; 
            border-radius: 5px;
            height: 8px;
        }
        /* Styles for the date filter UI */
        .date-range-slider-container {
            position: fixed;
            top: 175px; /* MODIFIED: Below Filter by Person (120px + ~45px height + 10px gap) */
            left: 20px;
            background-color: rgba(30, 30, 30, 0.85);
            padding: 10px 15px;
            border-radius: 5px;
            z-index: 1000;
            width: 280px; /* Adjust width to fit content */
        }
        .date-range-slider-container .slider-group {
            margin-bottom: 10px;
        }
        .date-range-slider-container label {
            font-size: 14px;
            color: #eee;
            display: block;
            margin-bottom: 5px;
        }
        .date-range-slider-container .date-display {
            font-size: 12px;
            color: #ccc;
            min-height: 1.2em; /* Prevent layout jump */
            margin-bottom: 5px;
        }
        .date-range-slider-container input[type="range"] {
            width: 100%;
            cursor: pointer;
            /* Basic styling, can be enhanced like previous slider */
            -webkit-appearance: none;
            appearance: none;
            height: 8px; 
            background: #555; 
            border-radius: 5px;
            outline: none;
        }
        .date-range-slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px; 
            height: 18px; 
            background: rgb(212, 94, 0); 
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff; 
        }
        .date-range-slider-container input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: rgb(212, 94, 0);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid #fff;
        }
        .date-range-slider-container .buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .date-range-slider-container button {
            padding: 5px 10px;
            border-radius: 3px;
            border: 1px solid #666;
            background-color: #555;
            color: #eee;
            cursor: pointer;
            flex-grow: 1; /* Make buttons share space */
        }
        .date-range-slider-container button:hover {
            background-color: #666;
        }

        /* Info Icon and Tooltip Styles */
        #info-icon-container {
            position: fixed;
            bottom: 20px; /* MODIFIED: Position from bottom */
            left: 20px;   /* MODIFIED: Position from left */
            z-index: 1001; 
        }
        #info-icon {
            font-size: 18px;
            color: #00ffff; /* Cyan, like other highlights */
            cursor: help;
            padding: 5px;
            border-radius: 50%;
            background-color: rgba(30, 30, 30, 0.85);
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #00ffff;
        }
        #info-tooltip {
            visibility: hidden; 
            width: 280px; 
            background-color: rgba(10, 10, 10, 0.97);
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 35px; /* MODIFIED: Position above the icon, adjust as needed based on icon height + desired gap */
            left: 0;      /* MODIFIED: Align with the left of the container */
            margin-left: 0; /* MODIFIED: Remove margin-left for centering when at corner */
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid #00ffff;
        }
        #info-tooltip ul {
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 0;
        }
        #info-tooltip li {
            margin-bottom: 4px;
        }
        #info-icon-container:hover #info-tooltip {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="info-icon-container">
        <div id="info-icon">â„¹</div>
        <div id="info-tooltip">
            <strong>Node Info:</strong>
            <ul>
                <li>Size: Smaller are older, larger are newer.</li>
                <li>Timeline Lines: Chronological order of memories.</li>
                <li><span style="color: #00ff00;">Bright Green:</span> Earliest memory in the current view.</li>
                <li><span style="color: #ff00ff;">Bright Purple:</span> Latest memory in the current view.</li>
                <li><span style="color: #ffffff;">White:</span> Fewer people involved.</li>
                <li><span style="color: #ffA500;">Yellow/Orange:</span> More people involved.</li>
                <li>If you see nothing make sure you have enabled TXT2VEC for memories and synced them.</li>
            </ul>
        </div>
    </div>

    <div class="toggle-switch-container">
        <label for="lineToggle">Show Timeline Lines:</label>
        <label class="toggle-switch">
            <input type="checkbox" id="lineToggle" checked>
            <span class="slider"></span>
        </label>
    </div>

    <div class="slider-container">
        <label for="pointSizeSlider">Node Size:</label>
        <input type="range" id="pointSizeSlider" min="25" max="100" value="100">
        <span id="pointSizeValue" style="margin-left: 10px; font-size: 14px; color: #eee;">100%</span>
    </div>

    <div class="filter-container">
        <label for="companionFilter">Filter by Person:</label>
        <select id="companionFilter">
            <option value="all">Show All</option>
            <!-- Companion options will be populated here by JavaScript -->
        </select>
    </div>

    <div class="date-range-slider-container">
        <div class="slider-group">
            <label for="startDateGamets">Start Date:</label>
            <span id="startDateDisplay" class="date-display">Not set</span>
            <input type="range" id="startDateGamets" value="0">
        </div>
        <div class="slider-group">
            <label for="endDateGamets">End Date:</label>
            <span id="endDateDisplay" class="date-display">Not set</span>
            <input type="range" id="endDateGamets" value="100">
        </div>
        <div class="overall-range-display" style="font-size: 10px; color: #aaa; margin-top: 5px;">
            (Overall available range: <span id="overallMinDateDisplay">N/A</span> to <span id="overallMaxDateDisplay">N/A</span>)
        </div>
        <div class="buttons">
            <button id="applyDateRangeFilter">Apply</button>
            <button id="resetDateRangeFilter">Reset</button>
        </div>
    </div>

    <!-- Old tooltip div is effectively removed by CSS -->
    <!-- <div id="tooltip"></div> --> 
    <div id="info-panel">
        <h3>Point Information</h3>
        <div class="data-section">
            <span class="label">In-Game Date:</span>
            <p id="info-skyrim-date">No point selected.</p>
        </div>
        <div class="data-section">
            <span class="label">Summary:</span>
            <p id="info-summary">No point selected.</p>
        </div>
        <div class="data-section">
            <span class="label">People:</span>
            <p id="info-companions"></p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, controls, labelRenderer;
        const pointsData = []; // To store data associated with each mesh
        let pointMeshes = []; // To store the THREE.Mesh objects for raycasting
        let arrowHelpers = []; // To store arrow helpers for potential removal/update
        let activePoint = null; // For hover effect

        let uiPointScaleMultiplier = 1.0; // ADDED: For UI point scaling

        let raycaster, mouse;
        let hoveredPoint = null;
        const tooltip = document.getElementById('tooltip');

        // --- Date to Gamets Conversion (JavaScript) ---
        const SKYRIM_EPOCH_YEAR = 201; // 4E 201
        const SKYRIM_EPOCH_MONTH_JS = 7; // August (0-indexed for JS Date)
        const SKYRIM_EPOCH_DAY = 17;
        // Base timestamp for 4E 201, August 17, 00:00:00 UTC - use UTC to avoid timezone issues in calculation
        const skyrimEpochBaseTimestamp = Date.UTC(SKYRIM_EPOCH_YEAR, SKYRIM_EPOCH_MONTH_JS, SKYRIM_EPOCH_DAY, 0, 0, 0);
        const GAMETS_PER_SECOND = 1 / 0.00864; // Approx 115.74

        function skyrimDateToGamets(yyyyMmDdString, isEndDate = false) {
            if (!yyyyMmDdString) return null;
            const parts = yyyyMmDdString.split('-');
            if (parts.length !== 3) return null;
            
            const year = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) - 1; // JS Date month is 0-indexed
            const day = parseInt(parts[2], 10);

            let targetTimestamp;
            if (isEndDate) {
                // For end date, consider end of that day
                targetTimestamp = Date.UTC(year, month, day, 23, 59, 59, 999);
            } else {
                targetTimestamp = Date.UTC(year, month, day, 0, 0, 0, 0);
            }

            const secondsFromEpoch = (targetTimestamp - skyrimEpochBaseTimestamp) / 1000;
            return Math.round(secondsFromEpoch * GAMETS_PER_SECOND);
        }
        // Note: gametsToSkyrimDateJS can be complex if trying to perfectly mirror PHP utils.
        // For now, api.php provides min/max calendar dates directly.
        // --- End Date Conversion ---

        // --- Gamets to Skyrim Date (JavaScript) ---
        const SKYRIM_MONTH_NAMES_JS = [
            "Morning Star", "Sun's Dawn", "First Seed", "Rain's Hand", 
            "Second Seed", "Mid Year", "Sun's Height", "Last Seed", 
            "Hearthfire", "Frost Fall", "Sun's Dusk", "Evening Star"
        ];

        function gametsToSkyrimDateJS(gametsValue) {
            if (gametsValue === null || gametsValue === undefined || gametsValue < 0) return "N/A";

            const secondsOffset = gametsValue / GAMETS_PER_SECOND;
            const targetTimestamp = skyrimEpochBaseTimestamp + (secondsOffset * 1000);
            const dateObj = new Date(targetTimestamp);

            const day = dateObj.getUTCDate();
            const monthIndex = dateObj.getUTCMonth(); // 0-11
            const year = dateObj.getUTCFullYear(); // This will be the Gregorian year of the epoch + offset
            
            // Simple way to display year: 4E + (year - 201 + 201) -> 4E + (Gregorian year of epoch + offset from epoch)
            // This needs to be aligned with how 4E 201 is established.
            // The skyrim_start_timestamp in PHP is '0201-08-17'. So year '201' is 4E 201.
            const skyrimEraYear = year; // Since our epoch is 201, the JS year maps directly for display.

            let daySuffix = 'th';
            if (day === 1 || day === 21 || day === 31) daySuffix = 'st';
            else if (day === 2 || day === 22) daySuffix = 'nd';
            else if (day === 3 || day === 23) daySuffix = 'rd';

            return `${day}${daySuffix} of ${SKYRIM_MONTH_NAMES_JS[monthIndex]}, 4E ${skyrimEraYear}`;
        }
        // --- End Gamets to Date ---

        // Global vars for slider bounds
        let overallMinGamets = 0;
        let overallMaxGamets = 100; // Default, will be updated

        async function fetchData(params = {}) {
            try {
                let url = 'api.php'; // MODIFIED: Base URL
                if (Object.keys(params).length > 0) {
                    const queryParams = new URLSearchParams(params);
                    url += `?${queryParams.toString()}`;
                }

                const response = await fetch(url);
                if (!response.ok) {
                    // Try to parse error from structured response
                    let errorMsg = `HTTP error! status: ${response.status}`;
                    try {
                        const errorData = await response.json();
                        errorMsg = errorData.error || errorMsg;
                    } catch (e) { /* ignore if error response isn't json */ }
                    throw new Error(errorMsg);
                }
                const responseData = await response.json(); // MODIFIED: Expect structured response
                console.log("Full response data fetched:", responseData);

                // Set date picker min/max if available from initial load
                if (params.initialLoad) {
                    if (responseData.min_calendar_date && responseData.max_calendar_date) {
                        document.getElementById('overallMinDateDisplay').textContent = responseData.min_calendar_date;
                        document.getElementById('overallMaxDateDisplay').textContent = responseData.max_calendar_date;
                    }
                    if (responseData.overall_min_gamets !== null && responseData.overall_max_gamets !== null) {
                        overallMinGamets = responseData.overall_min_gamets;
                        overallMaxGamets = responseData.overall_max_gamets;

                        const startDateSlider = document.getElementById('startDateGamets');
                        const endDateSlider = document.getElementById('endDateGamets');
                        startDateSlider.min = overallMinGamets;
                        startDateSlider.max = overallMaxGamets;
                        startDateSlider.value = overallMinGamets; // Default to full range
                        endDateSlider.min = overallMinGamets;
                        endDateSlider.max = overallMaxGamets;
                        endDateSlider.value = overallMaxGamets; // Default to full range

                        // Update display for initial slider values
                        document.getElementById('startDateDisplay').textContent = gametsToSkyrimDateJS(overallMinGamets);
                        document.getElementById('endDateDisplay').textContent = gametsToSkyrimDateJS(overallMaxGamets);
                    }
                }
                return responseData.data; // MODIFIED: Return actual data array
            } catch (error) {
                console.error("Could not fetch data:", error);
                // Display error to user in the info panel or a dedicated error div
                const infoSummary = document.getElementById('info-summary');
                if(infoSummary) infoSummary.textContent = `Error fetching data: ${error.message}`;
                return []; // Return empty array on error
            }
        }

        function init() {
            scene = new THREE.Scene();

            // REMOVED: Old background image loading via TextureLoader
            // const loader = new THREE.TextureLoader();
            // loader.load('images/background.jpg', function(texture) {
            //     scene.background = texture;
            // }, undefined, function(err) {
            //     console.error('An error happened while loading the background image.', err);
            // });

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30; // Adjusted camera position

            // MODIFIED: Added alpha: true to renderer, and set clear alpha to 0
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // Set clear color to transparent
            document.body.appendChild(renderer.domElement);

            // CSS2D Renderer for labels
            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none'; // Important for OrbitControls
            document.body.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('click', onClick, false);
            document.addEventListener('mousemove', onMouseMove, false); // Re-enabled for hover cursor

            // Add event listener for the toggle
            document.getElementById('lineToggle').addEventListener('change', function(event) {
                const selectedCompanion = document.getElementById('companionFilter').value;
                filterPointsByCompanion(selectedCompanion);
            });

            // Add event listener for point size slider // ADDED SECTION
            const pointSizeSlider = document.getElementById('pointSizeSlider');
            const pointSizeValueDisplay = document.getElementById('pointSizeValue');
            pointSizeSlider.addEventListener('input', function(event) {
                uiPointScaleMultiplier = parseInt(event.target.value) / 100.0;
                pointSizeValueDisplay.textContent = `${event.target.value}%`;
                applyPointSizeScaling();
            });
            // END ADDED SECTION

            // Add event listeners for date range sliders and buttons // MODIFIED SECTION
            const startDateSlider = document.getElementById('startDateGamets');
            const endDateSlider = document.getElementById('endDateGamets');
            const startDateDisplay = document.getElementById('startDateDisplay');
            const endDateDisplay = document.getElementById('endDateDisplay');

            startDateSlider.addEventListener('input', () => {
                let startVal = parseFloat(startDateSlider.value);
                let endVal = parseFloat(endDateSlider.value);
                if (startVal > endVal) {
                    startDateSlider.value = endVal; // Prevent start from exceeding end
                    startVal = endVal;
                }
                startDateDisplay.textContent = gametsToSkyrimDateJS(startVal);
            });

            endDateSlider.addEventListener('input', () => {
                let startVal = parseFloat(startDateSlider.value);
                let endVal = parseFloat(endDateSlider.value);
                if (endVal < startVal) {
                    endDateSlider.value = startVal; // Prevent end from being less than start
                    endVal = startVal;
                }
                endDateDisplay.textContent = gametsToSkyrimDateJS(endVal);
            });

            document.getElementById('applyDateRangeFilter').addEventListener('click', () => {
                const startGamets = parseFloat(startDateSlider.value);
                const endGamets = parseFloat(endDateSlider.value);

                if (endGamets >= startGamets) {
                    fetchData({ start_gamets: startGamets, end_gamets: endGamets }).then(data => {
                        if (data && data.length > 0) {
                            visualizeData(data);
                        } else {
                            visualizeData([]); 
                            console.log("No data to visualize for the selected date range or error occurred.");
                            document.getElementById('info-summary').textContent = 'No data for selected date range.';
                        }
                    });
                } else {
                    alert("Start date cannot be after end date."); // Should be prevented by slider logic but good fallback
                }
            });

            document.getElementById('resetDateRangeFilter').addEventListener('click', () => {
                startDateSlider.value = overallMinGamets;
                endDateSlider.value = overallMaxGamets;
                startDateDisplay.textContent = gametsToSkyrimDateJS(overallMinGamets);
                endDateDisplay.textContent = gametsToSkyrimDateJS(overallMaxGamets);
                
                fetchData({ initialLoad: false }).then(data => { // initialLoad: false as we don't need to reset bounds
                    if (data && data.length > 0) {
                        visualizeData(data);
                    } else {
                        visualizeData([]);
                        console.log("No data to visualize or error occurred.");
                    }
                });
            });
            // END MODIFIED SECTION

            fetchData({ initialLoad: true }).then(data => { // MODIFIED: Pass initialLoad true
                if (data && data.length > 0) {
                    visualizeData(data);
                } else {
                    console.log("No data to visualize or error occurred.");
                }
            });
        }

        function visualizeData(data) {
            // --- Cleanup previous objects ---
            pointMeshes.forEach(mesh => scene.remove(mesh));
            arrowHelpers.forEach(arrow => scene.remove(arrow));
            pointMeshes = [];
            arrowHelpers = [];
            pointsData.length = 0;
            // Potentially remove other dynamic objects if re-visualizing

            // --- Prepare for sizing ---
            let minGamets = Infinity;
            let maxGamets = -Infinity;
            data.forEach(item => {
                const gamets = parseInt(item.gamets_truncated, 10);
                if (!isNaN(gamets)) {
                    if (gamets < minGamets) minGamets = gamets;
                    if (gamets > maxGamets) maxGamets = gamets;
                }
            });
            const gametsRange = (maxGamets - minGamets) > 0 ? (maxGamets - minGamets) : 1; // Avoid division by zero

            const scaleFactor = 100; // MOVED scaleFactor DEFINITION HERE

            // --- Define size range for points ---
            const minPointSize = 0.1 * (scaleFactor / 100); // Min size of sphere radius
            const maxPointSize = 0.8 * (scaleFactor / 100); // Max size of sphere radius
            
            const baseSphereRadius = 0.05; // Base radius for spheres before scaling

            // --- Bounding box for camera ---
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            // --- Create points (meshes) and collect positions for arrows ---
            const arrowVertices = []; // Store center positions for arrows

            data.forEach((item, index) => {
                const vec = item.embedding;
                let x, y, z;

                if (vec && vec.length >= 3) {
                    x = vec[0] * scaleFactor;
                    y = vec[1] * scaleFactor;
                    z = vec[2] * scaleFactor;
                } else if (vec && vec.length > 0) {
                    x = (vec[0] || 0) * scaleFactor;
                    y = (vec[1] || 0) * scaleFactor;
                    z = 0;
                } else {
                    return; // Skip if no valid vector
                }

                const currentPosition = new THREE.Vector3(x, y, z);
                arrowVertices.push(currentPosition); 

                // Calculate size based on gamets_truncated (RESTORED)
                let pointSize = minPointSize;
                const gamets = parseInt(item.gamets_truncated, 10);
                if (!isNaN(gamets) && maxGamets > minGamets) {
                    const normalizedGamets = (gamets - minGamets) / gametsRange;
                    pointSize = minPointSize + normalizedGamets * (maxPointSize - minPointSize);
                }
                pointSize = Math.max(0.01 * (scaleFactor/100), pointSize); // Ensure size is not zero or negative, scaled minimum

                const sphereGeometry = new THREE.SphereGeometry(baseSphereRadius, 16, 12); 
                
                let pointColorValue;
                if (index === 0 && data.length > 0) { // First point (earliest)
                    pointColorValue = new THREE.Color(0x00ff00); // Bright Green
                } else if (index === data.length - 1 && data.length > 0) { // Last point (latest)
                    pointColorValue = new THREE.Color(0xff00ff); // Bright Purple (Magenta)
                } else {
                    // Existing color logic based on companions for intermediate points
                    let numCompanions = 0;
                    if (item.companions && typeof item.companions === 'string' && item.companions.trim() !== '') {
                        numCompanions = item.companions.split(',').length;
                    }
                    const t = Math.min(1, Math.max(0, numCompanions / 10)); // Normalize between 0 and 1
                    const r = 255;
                    const g = Math.round(255 - 135 * t); // (255 -> 120) for white to red-orange
                    const b = Math.round(255 - 255 * t); // (255 -> 0) for white to red-orange
                    pointColorValue = new THREE.Color(r / 255, g / 255, b / 255);
                }
                
                const sphereMaterial = new THREE.MeshBasicMaterial({ color: pointColorValue });
                const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
                
                sphereMesh.position.copy(currentPosition);
                sphereMesh.scale.set(pointSize / baseSphereRadius, pointSize / baseSphereRadius, pointSize / baseSphereRadius); // USE DYNAMIC pointSize

                sphereMesh.userData = { 
                    id: index, 
                    summary: item.summary, 
                    companions: item.companions, 
                    gamets_truncated: item.gamets_truncated,
                    skyrim_date: item.skyrim_date,
                    originalColor: pointColorValue.clone(),
                    baseScaleForUIScaling: sphereMesh.scale.clone(), // ADDED: Store the gamets-based scale
                };

                // Apply initial UI scaling
                sphereMesh.scale.multiplyScalar(uiPointScaleMultiplier);
                sphereMesh.userData.originalScale = sphereMesh.scale.clone(); // Set originalScale after UI scaling

                scene.add(sphereMesh);
                pointMeshes.push(sphereMesh);
                pointsData.push(sphereMesh.userData); // Keep pointsData for simpler access patterns if needed, but userData is key

                // Update bounding box
                if (x < minX) minX = x; if (x > maxX) maxX = x;
                if (y < minY) minY = y; if (y > maxY) maxY = y;
                if (z < minZ) minZ = z; if (z > maxZ) maxZ = z;
            });

            // --- Create ArrowHelpers for each segment to show direction ---
            if (arrowVertices.length > 1) {
                const arrowColor = 0x00ffff;
                const showLinesInitial = document.getElementById('lineToggle').checked; // Get initial state

                // --- Populate Companion Filter ---
                const companionFilterSelect = document.getElementById('companionFilter');
                const uniqueCompanions = new Set();
                const companionCounts = {}; // ADDED: Object to store companion counts

                data.forEach(item => {
                    if (item.companions && typeof item.companions === 'string') {
                        const companionsList = item.companions.split(',').map(c => c.trim()).filter(c => c !== '');
                        companionsList.forEach(c => {
                            uniqueCompanions.add(c);
                            companionCounts[c] = (companionCounts[c] || 0) + 1; // ADDED: Increment count
                        });
                    }
                });
                // Clear existing options except the first 'Show All'
                while (companionFilterSelect.options.length > 1) {
                    companionFilterSelect.remove(1);
                }
                const sortedCompanions = Array.from(uniqueCompanions).sort();
                sortedCompanions.forEach(companion => {
                    const option = document.createElement('option');
                    option.value = companion;
                    const count = companionCounts[companion] || 0; // ADDED: Get count
                    option.textContent = `${companion} (${count})`; // MODIFIED: Add count to text
                    companionFilterSelect.appendChild(option);
                });
                // END ADDED SECTION

                for (let i = 0; i < arrowVertices.length - 1; i++) {
                    const startPoint = arrowVertices[i];
                    const endPoint = arrowVertices[i+1];
                    const direction = new THREE.Vector3().subVectors(endPoint, startPoint);
                    const segmentLength = direction.length();
                    if (segmentLength > 0.001) {
                        direction.normalize();
                        let arrowHeadLength = segmentLength * 0.2;
                        let arrowHeadWidth = segmentLength * 0.1;
                        const minAbsHeadLength = 0.1; const maxAbsHeadLength = 1.0 * (scaleFactor/100);
                        const minAbsHeadWidth = 0.05; const maxAbsHeadWidth = 0.5 * (scaleFactor/100);
                        arrowHeadLength = Math.max(minAbsHeadLength, Math.min(arrowHeadLength, maxAbsHeadLength));
                        arrowHeadWidth = Math.max(minAbsHeadWidth, Math.min(arrowHeadWidth, maxAbsHeadWidth));
                        if (arrowHeadLength >= segmentLength * 0.9) {
                            arrowHeadLength = segmentLength * 0.5;
                            arrowHeadWidth = arrowHeadLength * 0.5;
                        }
                        const arrow = new THREE.ArrowHelper(direction, startPoint, segmentLength, arrowColor, arrowHeadLength, arrowHeadWidth);
                        arrow.visible = showLinesInitial; // Set initial visibility
                        scene.add(arrow);
                        arrowHelpers.push(arrow);
                    }
                }
            }
            
            // --- Auto-camera adjustment ---
            if (isFinite(minX) && isFinite(maxX)) {
                const extent = new THREE.Vector3(maxX - minX, maxY - minY, maxZ - minZ);
                const sceneCenter = new THREE.Vector3(minX + extent.x / 2, minY + extent.y / 2, minZ + extent.z / 2);
                controls.target.copy(sceneCenter);
                const maxDimension = Math.max(extent.x, extent.y, extent.z, 1.0); // Ensure maxDimension is at least 1
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDimension / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; 
                cameraZ = Math.max(cameraZ, 10); 
                camera.position.copy(sceneCenter);
                camera.position.z += cameraZ; 
                camera.lookAt(sceneCenter);
                controls.update();
            }
            // Add event listener for the companion filter
            document.getElementById('companionFilter').addEventListener('change', onCompanionFilterChange);

            console.log(`Processed ${pointMeshes.length} points for visualization.`);
            console.log("Camera Position:", camera.position);
            console.log("Controls Target (LookAt):", controls.target);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointMeshes); // Intersect with meshes

            if (activePoint) {
                // Revert previously hovered point
                activePoint.material.color.copy(activePoint.userData.originalColor);
                activePoint.scale.copy(activePoint.userData.originalScale);
                activePoint = null;
            }

            if (intersects.length > 0) {
                const intersectedMesh = intersects[0].object;
                document.body.style.cursor = 'pointer';
                activePoint = intersectedMesh;
                activePoint.material.color.set(0xff0000); // Highlight red
                activePoint.scale.copy(activePoint.userData.originalScale).multiplyScalar(1.5); // Scale up
            } else {
                document.body.style.cursor = 'default';
            }
        }

        function onClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pointMeshes); // Intersect with meshes
            
            const infoSummary = document.getElementById('info-summary');
            const infoCompanions = document.getElementById('info-companions');
            const infoSkyrimDate = document.getElementById('info-skyrim-date');

            if (intersects.length > 0) {
                const clickedMesh = intersects[0].object; 
                const clickedPointData = clickedMesh.userData;
                
                infoSummary.textContent = clickedPointData.summary || 'Not available';
                infoCompanions.textContent = clickedPointData.companions || 'Not available';
                infoSkyrimDate.textContent = clickedPointData.skyrim_date || 'Not available';
            } else {
                infoSummary.textContent = 'Click a point for details.';
                infoCompanions.textContent = '';
                infoSkyrimDate.textContent = 'No point selected.';
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera); // Render CSS2D labels
        }

        // New function to handle companion filter change
        function onCompanionFilterChange(event) {
            const selectedCompanion = event.target.value;
            filterPointsByCompanion(selectedCompanion);
        }

        // New function to filter points and arrows by companion
        function filterPointsByCompanion(selectedCompanion) {
            const showLines = document.getElementById('lineToggle').checked;
            const isShowAll = selectedCompanion === 'all';

            pointMeshes.forEach(mesh => {
                let isVisible = false;
                if (isShowAll) {
                    isVisible = true;
                } else {
                    const companions = mesh.userData.companions || '';
                    if (companions.split(',').map(c => c.trim()).includes(selectedCompanion)) {
                        isVisible = true;
                    }
                }
                mesh.visible = isVisible;
            });

            arrowHelpers.forEach((arrow, index) => {
                // Assuming arrow i connects point i and point i+1
                // This relies on pointMeshes and arrowHelpers being in corresponding order
                // and that arrowHelpers[i] connects pointMeshes[i] to pointMeshes[i+1]
                if (pointMeshes[index] && pointMeshes[index+1]) {
                    const startPointVisible = pointMeshes[index].visible;
                    const endPointVisible = pointMeshes[index+1].visible;
                    arrow.visible = showLines && startPointVisible && endPointVisible;
                } else {
                    arrow.visible = false; // Should not happen if data is consistent
                }
            });
        }

        // New function to apply UI point size scaling // ADDED FUNCTION
        function applyPointSizeScaling() {
            if (!pointMeshes || pointMeshes.length === 0) return;

            pointMeshes.forEach(mesh => {
                if (mesh.userData.baseScaleForUIScaling) {
                    // Start from the base scale and apply the UI multiplier
                    mesh.scale.copy(mesh.userData.baseScaleForUIScaling).multiplyScalar(uiPointScaleMultiplier);
                    // Update originalScale so hover effects are relative to the new UI-scaled size
                    mesh.userData.originalScale.copy(mesh.scale);
                }
            });

            // If a point is currently active/hovered, its scale might need to be re-adjusted
            // based on the new originalScale to maintain the hover magnification effect correctly.
            if (activePoint && activePoint.userData.originalScale) {
                activePoint.scale.copy(activePoint.userData.originalScale).multiplyScalar(1.5);
            }

            renderer.render(scene, camera); // Re-render the scene
        }
        // END ADDED FUNCTION

        init();
        animate();
    </script>
</body>
</html> 